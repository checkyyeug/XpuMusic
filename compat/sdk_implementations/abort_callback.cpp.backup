/**
 * @file abort_callback.cpp
 * @brief 操作中止回调机制的实现
 * @date 2025-12-09
 * 
 * abort_callback 是 foobar2000 中用于支持操作取消的核心机制。
 * 长时运行的操作会定期检查是否应中止。
 */

#include "common_includes.h"
#include <vector>
#include <functional>

namespace foobar2000_sdk {

// abort_callback 基础实现
// 提供标准的 is_aborting() 实现
class abort_callback_impl : public abort_callback {
private:
    // 原子标志，用于快速检查是否需要中止
    std::atomic<bool> aborted_{false};
    
    // 保护回调向量
    mutable std::mutex callback_mutex_;
    std::vector<std::function<bool()>> abort_callbacks_;

public:
    abort_callback_impl() = default;
    virtual ~abort_callback_impl() = default;
    
    /**
     * @brief 检查操作是否应该中止
     * @return true 如果应该中止，false 继续操作
     */
    bool is_aborting() const override {
        // 快速原子检查（只读，不修改）
        if (aborted_.load(std::memory_order_acquire)) {
            return true;
        }
        
        // 在 const 方法中不能修改状态，所以只检查不设置
        std::lock_guard<std::mutex> lock(callback_mutex_);
        for (const auto& callback : abort_callbacks_) {
            try {
                if (callback()) {
                    // 只在当前调用返回 true，不永久设置 aborted 标志
                    return true;
                }
            } catch (...) {
                // 回调中不应抛出异常，但如果抛出，视为中止
                return true;
            }
        }
        
        return false;
    }
    
    /**
     * @brief 检查操作是否应该中止（非 const 版本，可以设置标志）
     * @return true 如果应该中止，false 继续操作
     */
    bool check_is_aborting() {
        // 快速原子检查
        if (aborted_.load(std::memory_order_acquire)) {
            return true;
        }
        
        // 检查所有注册的回调函数
        std::lock_guard<std::mutex> lock(callback_mutex_);
        for (const auto& callback : abort_callbacks_) {
            try {
                if (callback()) {
                    // 如果有回调请求中止，设置标志并返回
                    aborted_.store(true, std::memory_order_release);
                    return true;
                }
            } catch (...) {
                // 回调中不应抛出异常，但如果抛出，视为中止
                aborted_.store(true, std::memory_order_release);
                return true;
            }
        }
        
        return false;
    }
    
    /**
     * @brief 强制设置中止标志
     */
    void set_aborted() {
        aborted_.store(true, std::memory_order_release);
    }
    
    /**
     * @brief 添加自定义中止检查回调
     * @param callback 返回 true 表示请求中止
     */
    void add_abort_callback(std::function<bool()> callback) {
        std::lock_guard<std::mutex> lock(callback_mutex_);
        abort_callbacks_.push_back(callback);
    }
    
    /**
     * @brief 清除所有中止状态 - 可重用的回调对象
     */
    void reset() {
        std::lock_guard<std::mutex> lock(callback_mutex_);
        aborted_.store(false, std::memory_order_release);
        abort_callbacks_.clear();
    }
};

// abort_callback_dummy 实现 - 永不中止
// 用于不允许取消的操作
bool abort_callback_dummy::is_aborting() const {
    return false;
}

// abort_callback_dummy 全局实例
// 操作无法取消时使用
t_abort_callback_dummy g_abort_callback_dummy;
abort_callback_dummy& abort_callback_dummy::instance() {
    return g_abort_callback_dummy;
}

} // namespace foobar2000_sdk
